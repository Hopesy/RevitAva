# Avalonia 窗口如何使用宿主的消息循环

本文档深入解释 `SetupWithoutStarting()` 的核心概念：**只初始化框架，让窗口使用宿主的消息循环**。

## 目录

- [什么是消息循环](#什么是消息循环)
- [什么是"初始化框架"](#什么是初始化框架)
- [什么是"宿主的消息循环"](#什么是宿主的消息循环)
- [Avalonia 窗口如何使用宿主的消息循环](#avalonia-窗口如何使用宿主的消息循环)
- [技术实现细节](#技术实现细节)
- [完整示例](#完整示例)

---

## 什么是消息循环

### Windows 消息循环基础

在 Windows 中，所有的 UI 事件（鼠标点击、键盘输入、窗口重绘等）都通过**消息**来传递。

**消息的结构**：
```csharp
struct MSG
{
    IntPtr hwnd;      // 目标窗口句柄
    uint message;     // 消息类型（WM_PAINT, WM_LBUTTONDOWN 等）
    IntPtr wParam;    // 消息参数 1
    IntPtr lParam;    // 消息参数 2
    uint time;        // 消息时间戳
    POINT pt;         // 鼠标位置
}
```

**标准的 Windows 消息循环**：
```csharp
// 这是所有 Windows 应用程序的核心
while (GetMessage(out MSG msg, IntPtr.Zero, 0, 0))
{
    // 1. 获取消息（阻塞，直到有消息）
    //    从操作系统的消息队列中取出一条消息

    // 2. 转换消息（处理键盘输入）
    TranslateMessage(ref msg);

    // 3. 分发消息（根据 hwnd 发送到对应窗口）
    DispatchMessage(ref msg);
    //    ↓
    //    调用窗口的 WndProc（窗口过程）
}
```

**消息流程**：
```
用户点击鼠标
    ↓
Windows 操作系统捕获事件
    ↓
生成 WM_LBUTTONDOWN 消息
    ↓
放入消息队列
    ↓
GetMessage() 取出消息
    ↓
DispatchMessage() 分发消息
    ↓
根据 msg.hwnd 找到目标窗口
    ↓
调用该窗口的 WndProc
    ↓
窗口处理消息
```

### 每个应用程序只能有一个消息循环

**关键点**：在同一个线程上，**只能有一个消息循环在运行**。

**为什么？**
```csharp
// 消息循环是阻塞的
while (GetMessage(out MSG msg, ...))  // ← 阻塞在这里
{
    DispatchMessage(ref msg);
}

// 如果启动第二个消息循环
while (GetMessage(out MSG msg, ...))  // ← 永远不会执行到这里！
{
    DispatchMessage(ref msg);
}
```

**如果强行启动两个消息循环会怎样？**
```csharp
// 线程 1
void Thread1()
{
    // Revit 的消息循环
    while (GetMessage(out MSG msg, ...))
    {
        DispatchMessage(ref msg);
    }
}

// 线程 1（同一个线程）
void Thread1_Again()
{
    // Avalonia 的消息循环
    while (GetMessage(out MSG msg, ...))  // ❌ 永远不会执行
    {
        DispatchMessage(ref msg);
    }
}
```

**结果**：
- 第一个消息循环会一直运行
- 第二个消息循环永远不会启动
- 或者导致死锁、消息丢失等问题

---

## 什么是"初始化框架"

### SetupWithoutStarting() 做的事情

```csharp
AppBuilder.Configure<Avalonia.Application>()
    .UsePlatformDetect()
    .SetupWithoutStarting();  // ← 这里
```

**"初始化框架"包括**：

#### 1. 注册平台服务

```csharp
// 注册 Windows 平台的实现
AvaloniaLocator.CurrentMutable
    .Bind<IPlatformThreadingInterface>()
    .ToConstant(Win32PlatformThreading.Instance);

AvaloniaLocator.CurrentMutable
    .Bind<IWindowingPlatform>()
    .ToConstant(Win32Platform.Instance);

AvaloniaLocator.CurrentMutable
    .Bind<IPlatformRenderInterface>()
    .ToConstant(SkiaRenderInterface.Instance);
```

**这些服务是什么？**

| 服务 | 作用 | 实现 |
|------|------|------|
| `IPlatformThreadingInterface` | 线程调度、定时器 | `Win32PlatformThreading` |
| `IWindowingPlatform` | 创建窗口、管理窗口 | `Win32Platform` |
| `IPlatformRenderInterface` | 渲染 UI | `SkiaRenderInterface` |
| `IClipboard` | 剪贴板操作 | `Win32Clipboard` |
| `ISystemDialogImpl` | 文件对话框 | `Win32SystemDialogs` |

#### 2. 初始化样式系统

```csharp
// 初始化样式引擎
Styling.StyleSystem.Initialize();

// 现在可以：
Application.Current.Styles.Add(new FluentTheme());
```

#### 3. 初始化资源系统

```csharp
// 初始化资源字典
Resources.ResourceSystem.Initialize();

// 现在可以：
Application.Current.Resources["MyBrush"] = new SolidColorBrush(Colors.Blue);
```

#### 4. 初始化输入系统

```csharp
// 初始化输入管理器
InputManager.Instance.Initialize();

// 现在可以处理：
// - 鼠标事件
// - 键盘事件
// - 触摸事件
```

#### 5. 设置 Application.Current

```csharp
// 设置全局应用程序实例
Application.Current = new Avalonia.Application();

// 现在可以访问：
Application.Current.Styles
Application.Current.Resources
Application.Current.Name
```

### 初始化后的状态

```csharp
// ✅ 框架已准备好
- 平台服务已注册
- 样式系统已初始化
- 资源系统已初始化
- 输入系统已初始化
- Application.Current 已设置

// ✅ 可以做的事情
- 创建窗口：new Window()
- 创建控件：new Button()
- 添加样式：Application.Current.Styles.Add(...)
- 使用资源：Application.Current.Resources[...]

// ❌ 没有做的事情
- 没有启动消息循环
- 没有创建 ApplicationLifetime
- 没有调用 OnFrameworkInitializationCompleted
```

---

## 什么是"宿主的消息循环"

### 在 Revit 插件场景中

**宿主**：Revit 应用程序

**宿主的消息循环**：Revit（WPF）的消息循环

```csharp
// Revit.exe 的 Main 方法（简化）
[STAThread]
static void Main()
{
    // 创建 WPF 应用程序
    var app = new RevitApplication();

    // 启动 WPF 应用程序
    app.Run();  // ← 这里启动了消息循环
    //    ↓
    //    内部调用 Dispatcher.Run()
    //    ↓
    //    while (GetMessage(...)) { ... }
}
```

**Revit 的消息循环一直在运行**：
```
Revit 启动
    ↓
启动消息循环 ← 开始
    ↓
处理 Revit 主窗口的消息
    ↓
处理 Revit 对话框的消息
    ↓
处理插件窗口的消息 ← Avalonia 窗口在这里
    ↓
...（一直运行）
    ↓
用户关闭 Revit
    ↓
消息循环结束 ← 结束
```

### 其他宿主示例

**Unity 插件**：
```csharp
// Unity 的消息循环
void Update()  // Unity 的主循环
{
    // 处理 Unity 的事件
    // 也会处理 Avalonia 窗口的消息
}
```

**Blender 插件**：
```python
# Blender 的消息循环
while True:
    # 处理 Blender 的事件
    # 也会处理 Avalonia 窗口的消息
    pass
```

---

## Avalonia 窗口如何使用宿主的消息循环

### 关键概念：窗口句柄（HWND）

每个窗口都有一个唯一的 HWND（窗口句柄）：

```csharp
// Revit 主窗口
HWND revitMainWindow = 0x00120456;

// Revit 对话框
HWND revitDialog = 0x00120789;

// Avalonia 窗口
HWND avaloniaWindow = 0x00120ABC;
```

**消息分发基于 HWND**：
```csharp
// Windows 消息循环
while (GetMessage(out MSG msg, IntPtr.Zero, 0, 0))
{
    // msg.hwnd 指示这条消息是给哪个窗口的

    if (msg.hwnd == 0x00120456)
    {
        // 这是给 Revit 主窗口的消息
        // 调用 Revit 主窗口的 WndProc
    }
    else if (msg.hwnd == 0x00120789)
    {
        // 这是给 Revit 对话框的消息
        // 调用 Revit 对话框的 WndProc
    }
    else if (msg.hwnd == 0x00120ABC)
    {
        // 这是给 Avalonia 窗口的消息
        // 调用 Avalonia 窗口的 WndProc ← 这里！
    }

    DispatchMessage(ref msg);
}
```

### Avalonia 窗口的创建过程

```csharp
// 在 Revit 插件中
var window = new SettingView();
window.Show();
```

**内部发生了什么**：

#### 步骤 1：创建窗口实例

```csharp
// SettingView 构造函数
public SettingView()
{
    InitializeComponent();
    // 此时还没有创建 Windows 窗口
}
```

#### 步骤 2：调用 Show()

```csharp
public void Show()
{
    // 1. 获取平台窗口实现
    var platformWindow = AvaloniaLocator.Current
        .GetService<IWindowingPlatform>()
        .CreateWindow();  // ← Win32WindowImpl

    // 2. 创建 Windows 窗口
    platformWindow.Show();
}
```

#### 步骤 3：Win32WindowImpl.Show()

```csharp
public class Win32WindowImpl : IWindowImpl
{
    private IntPtr _hwnd;

    public void Show()
    {
        // 1. 创建 Windows 窗口
        _hwnd = CreateWindowEx(
            0,                          // 扩展样式
            "AvaloniaWindow",           // 窗口类名
            "设置",                     // 窗口标题
            WS_OVERLAPPEDWINDOW,        // 窗口样式
            CW_USEDEFAULT,              // X 位置
            CW_USEDEFAULT,              // Y 位置
            800,                        // 宽度
            600,                        // 高度
            IntPtr.Zero,                // 父窗口
            IntPtr.Zero,                // 菜单
            IntPtr.Zero,                // 实例句柄
            IntPtr.Zero                 // 附加参数
        );

        // 2. 注册窗口过程
        SetWindowLongPtr(_hwnd, GWLP_WNDPROC,
            Marshal.GetFunctionPointerForDelegate(WndProc));

        // 3. 显示窗口
        ShowWindow(_hwnd, SW_SHOW);
        UpdateWindow(_hwnd);

        // ✅ 窗口已创建并显示
        // ✅ 窗口已注册到 Windows 消息系统
        // ✅ 不需要启动新的消息循环
    }

    // 窗口过程：处理发送给这个窗口的消息
    private IntPtr WndProc(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        switch (msg)
        {
            case WM_PAINT:
                OnPaint();
                break;

            case WM_LBUTTONDOWN:
                OnMouseDown(lParam);
                break;

            case WM_KEYDOWN:
                OnKeyDown(wParam);
                break;

            case WM_CLOSE:
                OnClose();
                break;

            // ... 处理所有消息
        }

        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}
```

### 消息流转过程

```
用户点击 Avalonia 窗口中的按钮
    ↓
Windows 生成 WM_LBUTTONDOWN 消息
    ↓
消息包含：
    - hwnd = 0x00120ABC（Avalonia 窗口的句柄）
    - message = WM_LBUTTONDOWN
    - wParam = 鼠标按钮
    - lParam = 鼠标位置
    ↓
放入 Windows 消息队列
    ↓
Revit 的消息循环（正在运行）
    ↓
GetMessage() 取出消息
    ↓
DispatchMessage() 分发消息
    ↓
根据 hwnd = 0x00120ABC 找到 Avalonia 窗口
    ↓
调用 Avalonia 窗口的 WndProc
    ↓
Win32WindowImpl.WndProc() 处理消息
    ↓
转换为 Avalonia 的 PointerPressed 事件
    ↓
触发按钮的 Click 事件
    ↓
执行按钮的命令
```

### 关键点：自动注册

**当你调用 `CreateWindowEx()` 时**：

```csharp
IntPtr hwnd = CreateWindowEx(...);
```

**Windows 自动做了这些事情**：
1. 创建窗口对象
2. 分配唯一的 HWND
3. **将窗口注册到当前线程的消息队列**
4. 将窗口过程（WndProc）与 HWND 关联

**结果**：
- 任何发送给这个 HWND 的消息
- 都会被当前线程的消息循环处理
- 都会调用对应的 WndProc

**不需要**：
- 不需要告诉 Revit"我创建了一个窗口"
- 不需要手动注册到消息循环
- 不需要启动新的消息循环

**Windows 自动处理一切！**

---

## 技术实现细节

### 线程亲和性

**关键点**：窗口必须在创建它的线程上处理消息。

```csharp
// Revit 主线程（UI 线程）
Thread mainThread = Thread.CurrentThread;

// Revit 的消息循环在主线程上运行
while (GetMessage(...))  // 主线程
{
    DispatchMessage(...);
}

// Avalonia 窗口也必须在主线程上创建
var window = new SettingView();  // 主线程
window.Show();                   // 主线程

// 窗口的 WndProc 会在主线程上被调用
WndProc(...)  // 主线程
```

**如果在其他线程创建窗口**：
```csharp
// ❌ 错误的做法
Task.Run(() =>
{
    var window = new SettingView();  // 后台线程
    window.Show();                   // ❌ 错误！
});

// 问题：
// 1. 窗口在后台线程创建
// 2. 但消息循环在主线程
// 3. 消息无法正确分发
// 4. 窗口无法响应
```

### Dispatcher 的作用

Avalonia 使用 `Dispatcher` 确保代码在 UI 线程上执行：

```csharp
// 在后台线程
Task.Run(() =>
{
    // 需要更新 UI
    Dispatcher.UIThread.Post(() =>
    {
        // 这段代码会在 UI 线程上执行
        button.Content = "已完成";
    });
});
```

**Dispatcher 的实现**：
```csharp
public class Dispatcher
{
    public void Post(Action action)
    {
        // 发送一个自定义消息到 UI 线程
        PostMessage(_hwnd, WM_USER_INVOKE, IntPtr.Zero, IntPtr.Zero);

        // 在 WndProc 中处理
        case WM_USER_INVOKE:
            action();  // 在 UI 线程上执行
            break;
    }
}
```

### 为什么不需要 Avalonia 的消息循环？

**Avalonia 的消息循环做什么？**
```csharp
// Avalonia 的消息循环（StartWithClassicDesktopLifetime）
public void Run()
{
    while (!_shutdownRequested)
    {
        // 1. 获取消息
        GetMessage(out MSG msg, ...);

        // 2. 分发消息
        DispatchMessage(ref msg);

        // 3. 处理 Avalonia 的内部任务
        ProcessAvaloniaJobs();
    }
}
```

**在插件场景中**：
```csharp
// Revit 的消息循环已经在做这些事情
while (true)
{
    // 1. 获取消息（包括 Avalonia 窗口的消息）
    GetMessage(out MSG msg, ...);

    // 2. 分发消息（自动分发到 Avalonia 窗口）
    DispatchMessage(ref msg);

    // 3. 处理 WPF 的内部任务
    ProcessWpfJobs();
}

// ✅ Avalonia 窗口的消息已经被处理了
// ✅ 不需要 Avalonia 自己的消息循环
```

---

## 完整示例

### 场景：Revit 插件显示 Avalonia 窗口

```csharp
// Application.cs - 插件启动
public class Application : IExternalApplication
{
    public Result OnStartup(UIControlledApplication application)
    {
        // 1. 初始化 Avalonia 框架
        AppBuilder.Configure<Avalonia.Application>()
            .UsePlatformDetect()
            .SetupWithoutStarting();  // ← 只初始化，不启动消息循环

        // 2. 添加主题
        Avalonia.Application.Current!.Styles.Add(new FluentTheme());

        // 3. 立即返回，让 Revit 继续启动
        return Result.Succeeded;
    }
}

// SettingCommand.cs - 显示窗口
public class SettingCommand : IExternalCommand
{
    public Result Execute(...)
    {
        // 创建并显示窗口
        var window = new SettingView();
        window.Show();  // ← 使用 Revit 的消息循环

        return Result.Succeeded;
    }
}
```

### 执行流程

```
1. Revit 启动
    ↓
2. 加载插件
    ↓
3. 调用 Application.OnStartup()
    ↓
4. SetupWithoutStarting() - 初始化 Avalonia
    ├─ 注册平台服务（Win32Platform）
    ├─ 初始化样式系统
    ├─ 初始化资源系统
    ├─ 初始化输入系统
    └─ 设置 Application.Current
    ↓
5. OnStartup() 返回
    ↓
6. Revit 继续启动
    ↓
7. Revit 显示主窗口
    ↓
8. Revit 启动消息循环 ← 开始运行
    ↓
9. 用户点击插件按钮
    ↓
10. 调用 SettingCommand.Execute()
    ↓
11. new SettingView() - 创建窗口对象
    ↓
12. window.Show()
    ├─ 调用 Win32Platform.CreateWindow()
    ├─ 创建 Win32WindowImpl
    ├─ 调用 CreateWindowEx() - 创建 Windows 窗口
    │   └─ 返回 HWND = 0x00120ABC
    ├─ 注册 WndProc
    └─ 调用 ShowWindow() - 显示窗口
    ↓
13. 窗口已显示，等待用户交互
    ↓
14. 用户点击窗口中的按钮
    ↓
15. Windows 生成 WM_LBUTTONDOWN 消息
    ├─ hwnd = 0x00120ABC
    └─ 放入消息队列
    ↓
16. Revit 的消息循环（正在运行）
    ├─ GetMessage() - 取出消息
    ├─ DispatchMessage() - 分发消息
    └─ 根据 hwnd 找到 Avalonia 窗口
    ↓
17. 调用 Win32WindowImpl.WndProc()
    ├─ 处理 WM_LBUTTONDOWN
    ├─ 转换为 Avalonia 的 PointerPressed 事件
    └─ 触发按钮的 Click 事件
    ↓
18. 执行按钮的命令
    ↓
19. 继续等待下一条消息...
```

### 关键点总结

1. **Avalonia 只初始化框架**：
   - 注册平台服务
   - 初始化样式、资源、输入系统
   - 不启动消息循环

2. **Avalonia 窗口自动注册到 Windows**：
   - 调用 `CreateWindowEx()` 创建窗口
   - Windows 自动将窗口注册到当前线程的消息队列
   - 不需要手动注册

3. **使用宿主的消息循环**：
   - Revit 的消息循环一直在运行
   - 自动处理所有窗口的消息（包括 Avalonia 窗口）
   - 根据 HWND 分发消息到对应的 WndProc

4. **和平共处**：
   - Revit 窗口 → WPF 处理
   - Avalonia 窗口 → Avalonia.Win32 处理
   - 共享同一个消息循环
   - 互不干扰

---

## 类比理解

### 类比 1：餐厅服务员

**独立应用（StartWithClassicDesktopLifetime）**：
```
你开了一家餐厅
    ↓
你雇了一个服务员（消息循环）
    ↓
服务员只服务你的顾客（你的窗口）
```

**插件（SetupWithoutStarting）**：
```
你在别人的餐厅里摆了个摊位
    ↓
餐厅已经有服务员了（Revit 的消息循环）
    ↓
你不需要雇自己的服务员
    ↓
餐厅的服务员会服务所有顾客（包括你的）
```

### 类比 2：快递配送

**独立应用**：
```
你是一家独立的电商公司
    ↓
你有自己的快递员（消息循环）
    ↓
快递员只配送你的包裹（你的消息）
```

**插件**：
```
你在淘宝上开了个店
    ↓
淘宝已经有快递系统了（Revit 的消息循环）
    ↓
你不需要自己的快递员
    ↓
淘宝的快递系统会配送所有包裹（包括你的）
```

---

**总结**：`SetupWithoutStarting()` 只是让 Avalonia "准备好"，但不接管控制权。窗口创建后，自动融入宿主的消息循环，就像在别人的餐厅里摆摊，使用餐厅现有的服务员一样。
