# StartWithClassicDesktopLifetime 与 SetupWithoutStarting 的区别

本文档详细解释 Avalonia 的两种初始化方式，以及为什么在 Revit 插件中必须使用 `SetupWithoutStarting()`。

## 目录

- [两种初始化方式对比](#两种初始化方式对比)
- [StartWithClassicDesktopLifetime 详解](#startWithclassicdesktoplifetime-详解)
- [SetupWithoutStarting 详解](#setupwithoutstarting-详解)
- [为什么插件必须使用 SetupWithoutStarting](#为什么插件必须使用-setupwithoutstarting)
- [实际代码示例](#实际代码示例)

---

## 两种初始化方式对比

| 特性 | StartWithClassicDesktopLifetime | SetupWithoutStarting |
|------|--------------------------------|---------------------|
| **用途** | 独立桌面应用程序 | 嵌入式场景（插件、库） |
| **启动消息循环** | ✅ 是 | ❌ 否 |
| **管理应用程序生命周期** | ✅ 是 | ❌ 否 |
| **创建主窗口** | ✅ 可以 | ❌ 否 |
| **阻塞当前线程** | ✅ 是（直到应用退出） | ❌ 否（立即返回） |
| **处理 Shutdown 事件** | ✅ 是 | ❌ 否 |
| **适用场景** | 独立 .exe 应用 | Revit 插件、Unity 插件等 |

---

## StartWithClassicDesktopLifetime 详解

### 用途

用于**独立的桌面应用程序**，完全控制应用程序的生命周期。

### 典型使用场景

```csharp
// Program.cs - 独立应用程序的入口点
class Program
{
    [STAThread]
    static void Main(string[] args)
    {
        AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace()
            .StartWithClassicDesktopLifetime(args);  // ← 这里

        // ⚠️ 注意：这行代码不会立即执行！
        // StartWithClassicDesktopLifetime 会阻塞，直到应用程序退出
        Console.WriteLine("应用程序已退出");
    }
}
```

### 内部实现（简化）

```csharp
public static int StartWithClassicDesktopLifetime<TApp>(
    this AppBuilder builder,
    string[] args)
    where TApp : Application, new()
{
    // 1. 初始化 Avalonia 框架
    builder.SetupWithoutStarting();

    // 2. 创建桌面生命周期管理器
    var lifetime = new ClassicDesktopStyleApplicationLifetime
    {
        Args = args,
        ShutdownMode = ShutdownMode.OnLastWindowClose  // 最后一个窗口关闭时退出
    };

    // 3. 设置应用程序生命周期
    Application.Current.ApplicationLifetime = lifetime;

    // 4. 触发 OnFrameworkInitializationCompleted
    Application.Current.OnFrameworkInitializationCompleted();

    // 5. 启动消息循环（阻塞！）
    return lifetime.Start(args);  // ← 这里会阻塞
}
```

### 消息循环启动

```csharp
public class ClassicDesktopStyleApplicationLifetime
{
    public int Start(string[] args)
    {
        // 1. 触发 Startup 事件
        OnStartup(args);

        // 2. 如果设置了 MainWindow，显示它
        if (MainWindow != null)
        {
            MainWindow.Show();
        }

        // 3. 启动 Windows 消息循环（阻塞！）
        Dispatcher.UIThread.MainLoop();  // ← 阻塞在这里

        // 4. 消息循环结束后，触发 Exit 事件
        OnExit();

        return ExitCode;
    }
}
```

### 消息循环的实现

```csharp
public void MainLoop()
{
    // Windows 消息循环
    while (!_shutdownRequested)
    {
        // 获取消息
        if (GetMessage(out MSG msg, IntPtr.Zero, 0, 0))
        {
            // 处理消息
            TranslateMessage(ref msg);
            DispatchMessage(ref msg);
        }
        else
        {
            // WM_QUIT 消息，退出循环
            break;
        }
    }
}
```

### 生命周期事件

```csharp
public class ClassicDesktopStyleApplicationLifetime
{
    // 应用程序启动时触发
    public event EventHandler<ControlledApplicationLifetimeStartupEventArgs> Startup;

    // 应用程序退出时触发
    public event EventHandler<ControlledApplicationLifetimeExitEventArgs> Exit;

    // 主窗口
    public Window MainWindow { get; set; }

    // 退出模式
    public ShutdownMode ShutdownMode { get; set; }
    // - OnLastWindowClose: 最后一个窗口关闭时退出
    // - OnMainWindowClose: 主窗口关闭时退出
    // - OnExplicitShutdown: 显式调用 Shutdown() 时退出
}
```

### 完整示例

```csharp
// App.axaml.cs
public class App : Application
{
    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            // 设置主窗口
            desktop.MainWindow = new MainWindow();

            // 订阅启动事件
            desktop.Startup += (s, e) =>
            {
                Console.WriteLine("应用程序启动");
            };

            // 订阅退出事件
            desktop.Exit += (s, e) =>
            {
                Console.WriteLine("应用程序退出");
            };
        }

        base.OnFrameworkInitializationCompleted();
    }
}

// Program.cs
class Program
{
    [STAThread]
    static void Main(string[] args)
    {
        AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .StartWithClassicDesktopLifetime(args);
    }
}
```

### 执行流程

```
Main() 开始
    ↓
Configure<App>()
    ↓
UsePlatformDetect()
    ↓
StartWithClassicDesktopLifetime()
    ↓
SetupWithoutStarting() - 初始化框架
    ↓
创建 ClassicDesktopStyleApplicationLifetime
    ↓
OnFrameworkInitializationCompleted() - 设置主窗口
    ↓
显示主窗口
    ↓
启动消息循环 ← 阻塞在这里
    ↓
（用户关闭所有窗口）
    ↓
消息循环结束
    ↓
触发 Exit 事件
    ↓
返回退出代码
    ↓
Main() 结束
```

---

## SetupWithoutStarting 详解

### 用途

用于**嵌入式场景**，只初始化 Avalonia 框架，不接管应用程序生命周期。

### 典型使用场景

```csharp
// Revit 插件的 Application.cs
public class Application : IExternalApplication
{
    public Result OnStartup(UIControlledApplication application)
    {
        // 初始化 Avalonia
        AppBuilder.Configure<Avalonia.Application>()
            .UsePlatformDetect()
            .LogToTrace()
            .SetupWithoutStarting();  // ← 这里

        // 添加主题
        Avalonia.Application.Current!.Styles.Add(new FluentTheme());

        // ✅ 立即返回，不阻塞
        return Result.Succeeded;
    }
}
```

### 内部实现（简化）

```csharp
public static AppBuilder SetupWithoutStarting(this AppBuilder builder)
{
    // 1. 初始化平台服务
    AvaloniaLocator.CurrentMutable
        .Bind<IPlatformThreadingInterface>()
        .ToConstant(PlatformThreadingInterface.Instance);

    // 2. 初始化渲染器
    AvaloniaLocator.CurrentMutable
        .Bind<IPlatformRenderInterface>()
        .ToConstant(PlatformRenderInterface.Instance);

    // 3. 初始化输入管理器
    InputManager.Instance.Initialize();

    // 4. 初始化样式系统
    Styling.StyleSystem.Initialize();

    // 5. 初始化资源系统
    Resources.ResourceSystem.Initialize();

    // 6. 设置当前应用程序实例
    Application.Current = builder.Instance;

    // 7. 调用 Initialize() 方法
    Application.Current.Initialize();

    // ⚠️ 注意：不调用 OnFrameworkInitializationCompleted()
    // ⚠️ 注意：不创建 ApplicationLifetime
    // ⚠️ 注意：不启动消息循环

    // ✅ 立即返回
    return builder;
}
```

### 与 StartWithClassicDesktopLifetime 的关键区别

```csharp
// StartWithClassicDesktopLifetime 做的额外工作：
public static int StartWithClassicDesktopLifetime(...)
{
    // 1. 调用 SetupWithoutStarting()
    builder.SetupWithoutStarting();

    // 2. 创建生命周期管理器（SetupWithoutStarting 不做）
    var lifetime = new ClassicDesktopStyleApplicationLifetime();
    Application.Current.ApplicationLifetime = lifetime;

    // 3. 调用 OnFrameworkInitializationCompleted（SetupWithoutStarting 不做）
    Application.Current.OnFrameworkInitializationCompleted();

    // 4. 启动消息循环（SetupWithoutStarting 不做）
    return lifetime.Start(args);  // ← 阻塞
}
```

### 初始化后的状态

使用 `SetupWithoutStarting()` 后：

```csharp
// ✅ 可以做的事情
- 创建窗口：new Window()
- 显示窗口：window.Show()
- 创建控件：new Button()
- 使用样式：Application.Current.Styles.Add(...)
- 使用资源：Application.Current.Resources[...]

// ❌ 不能做的事情
- 访问 ApplicationLifetime（为 null）
- 使用 Shutdown() 方法（没有生命周期管理）
- 依赖 OnFrameworkInitializationCompleted 事件（不会触发）
```

### 窗口如何工作？

即使没有启动消息循环，窗口仍然可以工作：

```csharp
// 在 Revit 插件中
var window = new SettingView();
window.Show();  // ✅ 可以工作

// 原因：
// 1. window.Show() 创建 Windows 窗口（HWND）
// 2. 窗口注册到 Windows 消息循环
// 3. 使用 Revit 的消息循环（WPF 的）
// 4. 不需要 Avalonia 自己的消息循环
```

---

## 为什么插件必须使用 SetupWithoutStarting

### 原因 1：避免消息循环冲突

**问题**：如果在 Revit 插件中使用 `StartWithClassicDesktopLifetime`：

```csharp
// ❌ 错误的做法
public Result OnStartup(UIControlledApplication application)
{
    AppBuilder.Configure<App>()
        .UsePlatformDetect()
        .StartWithClassicDesktopLifetime(args);  // ← 阻塞！

    // ⚠️ 这行代码永远不会执行！
    return Result.Succeeded;
}
```

**后果**：
```
Revit 启动
    ↓
加载插件
    ↓
调用 OnStartup()
    ↓
StartWithClassicDesktopLifetime() ← 阻塞在这里！
    ↓
Revit 主窗口无法显示
    ↓
Revit 看起来"卡死"了
```

### 原因 2：生命周期管理冲突

**Revit 的生命周期**：
```
Revit.exe 启动
    ↓
加载插件（OnStartup）
    ↓
显示 Revit 主窗口
    ↓
用户使用 Revit
    ↓
用户关闭 Revit
    ↓
卸载插件（OnShutdown）
    ↓
Revit.exe 退出
```

**如果使用 StartWithClassicDesktopLifetime**：
```
Revit.exe 启动
    ↓
加载插件（OnStartup）
    ↓
StartWithClassicDesktopLifetime() ← 试图接管生命周期
    ↓
❌ 冲突！谁来管理应用程序生命周期？
    ↓
❌ Revit 无法正常工作
```

### 原因 3：消息循环已存在

**Revit 已经有消息循环**：

```csharp
// Revit 内部（简化）
[STAThread]
static void Main()
{
    // Revit 启动 WPF 应用程序
    var app = new RevitApplication();
    app.Run();  // ← WPF 的消息循环

    // 这个消息循环会一直运行，直到 Revit 退出
}
```

**如果 Avalonia 也启动消息循环**：

```
Windows 消息队列
    ↓
    ├─ Revit 的消息循环（WPF）
    │   └─ 处理 Revit 窗口的消息
    │
    └─ Avalonia 的消息循环 ← ❌ 冲突！
        └─ 试图处理所有消息
```

**结果**：
- 消息分发混乱
- 窗口无法正常响应
- 可能导致死锁或崩溃

### 正确的做法

```csharp
// ✅ 正确的做法
public Result OnStartup(UIControlledApplication application)
{
    // 只初始化框架，不启动生命周期
    AppBuilder.Configure<Avalonia.Application>()
        .UsePlatformDetect()
        .SetupWithoutStarting();  // ← 立即返回

    // 添加主题
    Avalonia.Application.Current!.Styles.Add(new FluentTheme());

    // ✅ 立即返回，让 Revit 继续启动
    return Result.Succeeded;
}
```

**工作原理**：
```
Revit 的消息循环（已存在）
    ↓
    ├─ Revit 窗口的消息
    │   └─ WPF 处理
    │
    └─ Avalonia 窗口的消息
        └─ Avalonia.Win32 处理

✅ 和平共处，各自处理各自的窗口
```

---

## 实际代码示例

### 独立应用程序（使用 StartWithClassicDesktopLifetime）

```csharp
// Program.cs
class Program
{
    [STAThread]
    static void Main(string[] args)
    {
        Console.WriteLine("应用程序启动前");

        AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace()
            .StartWithClassicDesktopLifetime(args);

        // ⚠️ 这行代码要等到应用程序退出后才会执行
        Console.WriteLine("应用程序已退出");
    }
}

// App.axaml.cs
public class App : Application
{
    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow();
        }

        base.OnFrameworkInitializationCompleted();
    }
}
```

**执行顺序**：
```
1. 输出："应用程序启动前"
2. 显示主窗口
3. （用户使用应用程序）
4. （用户关闭窗口）
5. 输出："应用程序已退出"
```

### Revit 插件（使用 SetupWithoutStarting）

```csharp
// Application.cs
public class Application : IExternalApplication
{
    private static bool _avaloniaInitialized;

    public Result OnStartup(UIControlledApplication application)
    {
        Console.WriteLine("插件启动前");

        // 初始化 Avalonia
        InitializeAvalonia();

        Console.WriteLine("插件启动后");  // ✅ 立即执行

        return Result.Succeeded;
    }

    private static void InitializeAvalonia()
    {
        if (_avaloniaInitialized) return;

        AppBuilder.Configure<Avalonia.Application>()
            .UsePlatformDetect()
            .LogToTrace()
            .SetupWithoutStarting();  // ← 立即返回

        Avalonia.Application.Current!.Styles.Add(new FluentTheme());

        _avaloniaInitialized = true;
    }
}

// SettingCommand.cs
public class SettingCommand : IExternalCommand
{
    public Result Execute(...)
    {
        // 创建并显示窗口
        var window = new SettingView();
        window.Show();  // ✅ 使用 Revit 的消息循环

        return Result.Succeeded;
    }
}
```

**执行顺序**：
```
1. 输出："插件启动前"
2. 初始化 Avalonia（立即返回）
3. 输出："插件启动后"
4. Revit 继续启动
5. （用户点击插件按钮）
6. 显示 Avalonia 窗口
```

---

## 总结

### 关键区别

| 方法 | 阻塞 | 消息循环 | 生命周期管理 | 适用场景 |
|------|------|---------|-------------|---------|
| `StartWithClassicDesktopLifetime` | ✅ 是 | ✅ 启动 | ✅ 管理 | 独立应用 |
| `SetupWithoutStarting` | ❌ 否 | ❌ 不启动 | ❌ 不管理 | 插件/嵌入 |

### 选择指南

**使用 StartWithClassicDesktopLifetime 当**：
- ✅ 你在开发独立的桌面应用程序
- ✅ 你的应用程序有 Main 入口点
- ✅ 你需要管理应用程序生命周期
- ✅ 你需要主窗口和退出逻辑

**使用 SetupWithoutStarting 当**：
- ✅ 你在开发插件（Revit、Unity、Blender 等）
- ✅ 宿主应用已经有消息循环
- ✅ 你不需要管理应用程序生命周期
- ✅ 你只需要显示窗口

### 记忆口诀

- **StartWithClassicDesktopLifetime**：我是老大，我说了算（独立应用）
- **SetupWithoutStarting**：我是客人，听主人的（插件）

---

**参考资源**：
- [Avalonia Application Lifetimes](https://docs.avaloniaui.net/docs/concepts/application-lifetimes)
- [Avalonia Embedding](https://docs.avaloniaui.net/docs/guides/building-cross-platform-applications/embedding-avalonia)
