# Avalonia 应用程序初始化方式对比

## 概述

Avalonia 应用程序有两种主要的初始化方式：
1. **标准应用模式**：使用 `App.axaml` 和自定义 `Application` 类
2. **插件集成模式**：直接使用 `Avalonia.Application` 框架类（本项目采用）

## 1. 标准应用模式（独立 Avalonia 应用）

### 项目结构
```
MyAvaloniaApp/
├── App.axaml              # 应用程序资源定义
├── App.axaml.cs           # 应用程序逻辑
├── Program.cs             # 入口点
└── Views/
    └── MainWindow.axaml
```

### App.axaml（应用程序资源）
```xml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="MyAvaloniaApp.App">
    <Application.Styles>
        <FluentTheme />
        <!-- 全局样式和资源 -->
    </Application.Styles>
</Application>
```

### App.axaml.cs（应用程序类）
```csharp
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;

namespace MyAvaloniaApp;

public partial class App : Application
{
    public override void Initialize()
    {
        // 加载 XAML 资源
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            // 设置主窗口
            desktop.MainWindow = new MainWindow();
        }

        base.OnFrameworkInitializationCompleted();
    }
}
```

### Program.cs（入口点）
```csharp
using Avalonia;
using System;

namespace MyAvaloniaApp;

class Program
{
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
        .StartWithClassicDesktopLifetime(args);  // 启动应用程序生命周期

    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()  // 配置自定义 App 类
            .UsePlatformDetect()
            .LogToTrace();
}
```

### 特点
- ✅ **拥有完整的应用程序生命周期**：启动、关闭事件
- ✅ **XAML 资源集中管理**：样式、主题在 App.axaml 中定义
- ✅ **主窗口管理**：`MainWindow` 由 ApplicationLifetime 管理
- ✅ **单例应用**：整个进程只有一个 Application 实例
- ❌ **独占消息循环**：需要独立的 UI 线程

---

## 2. 插件集成模式（Revit 插件环境）

### 项目结构
```
RevitAva/
├── Application.cs         # Revit 外部应用（非 Avalonia App）
├── Host.cs               # 依赖注入容器
└── Views/
    └── SettingView.axaml
```

### Application.cs（Revit 插件入口）
```csharp
using Avalonia;
using Semi.Avalonia;

namespace RevitAva;

public class Application : IExternalApplication  // Revit 接口，非 Avalonia.Application
{
    public Result OnStartup(UIControlledApplication application)
    {
        // 初始化 Avalonia（借用 Revit 的消息循环）
        AppBuilder.Configure<Avalonia.Application>()  // ⚠️ 使用框架内置类
            .UsePlatformDetect()
            .LogToTrace()
            .SetupWithoutStarting();  // ⚠️ 不启动应用程序生命周期

        // 手动添加主题
        Avalonia.Application.Current!.Styles.Add(new SemiTheme());

        return Result.Succeeded;
    }
}
```

### 特点
- ✅ **借用宿主消息循环**：复用 Revit 的 UI 线程
- ✅ **按需创建窗口**：不需要预先定义 MainWindow
- ✅ **轻量级集成**：无需完整的应用程序生命周期
- ❌ **无 App.axaml**：手动在代码中添加样式和主题
- ❌ **无应用程序生命周期事件**：没有 OnStartup/OnExit

---

## 3. 核心区别对比

| 特性 | 标准应用模式 | 插件集成模式（本项目） |
|------|-------------|---------------------|
| **Application 类型** | 自定义继承 `Avalonia.Application` | 直接使用 `Avalonia.Application` |
| **App.axaml** | ✅ 必需，定义全局资源 | ❌ 不存在 |
| **启动方法** | `.StartWithClassicDesktopLifetime()` | `.SetupWithoutStarting()` |
| **消息循环** | Avalonia 创建并管理 | 借用宿主（Revit）的消息循环 |
| **主窗口管理** | `ApplicationLifetime.MainWindow` | 手动 `new Window().Show()` |
| **样式/主题** | XAML 中声明 | 代码中添加 |
| **生命周期事件** | `OnFrameworkInitializationCompleted()` 等 | 由宿主管理（Revit OnStartup/OnShutdown） |
| **适用场景** | 独立桌面应用程序 | 插件、嵌入式 UI |

---

## 4. 为什么 Revit 插件使用 `Avalonia.Application`？

### 技术原因

#### 1. **Windows 消息循环机制**
```
┌─────────────────────────────────────┐
│   Revit.exe (宿主进程)               │
│   ┌─────────────────────────────┐   │
│   │  Revit 消息循环 (已运行)     │   │
│   │  while(GetMessage(...))      │   │
│   │  {                           │   │
│   │    DispatchMessage(...)      │   │
│   │  }                           │   │
│   └─────────────────────────────┘   │
│                                     │
│   ┌─────────────────────────────┐   │
│   │  RevitAva 插件               │   │
│   │  - 借用上述消息循环           │   │
│   │  - 创建 Avalonia 窗口        │   │
│   │  - 窗口注册到 Windows (HWND) │   │
│   └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

- Windows 的消息分发**基于 HWND**（窗口句柄），不是基于框架
- 每个窗口有自己的 HWND 和 WndProc（窗口过程）
- **只要有一个消息循环在运行，所有窗口都能工作**
- Revit 的消息循环已经在运行，插件只需"注册"窗口即可

#### 2. **Avalonia 设计限制**
> Avalonia by design can have only one Avalonia App instance to be built from one hosting app.

- **一个进程只能有一个 `Application` 实例**
- Revit 可能加载多个插件，如果都尝试创建 Application 会冲突
- 使用框架内置的 `Avalonia.Application` 避免类型冲突

#### 3. **生命周期冲突**
```csharp
// ❌ 不适合插件环境
.StartWithClassicDesktopLifetime(args)
// - 会阻塞当前线程（等待应用关闭）
// - Revit 需要继续运行，不能被阻塞

// ✅ 适合插件环境
.SetupWithoutStarting()
// - 仅初始化 Avalonia 框架
// - 不启动独立的应用程序生命周期
// - 立即返回，Revit 继续运行
```

---

## 5. 样式和主题管理对比

### 标准应用模式：App.axaml
```xml
<Application xmlns="https://github.com/avaloniaui"
             x:Class="MyApp.App">
    <Application.Styles>
        <FluentTheme />
        <StyleInclude Source="/Styles/CustomStyles.axaml"/>
    </Application.Styles>

    <Application.Resources>
        <SolidColorBrush x:Key="PrimaryBrush">#FF0078D7</SolidColorBrush>
    </Application.Resources>
</Application>
```

### 插件集成模式：代码添加
```csharp
// 在 Application.cs 中
AppBuilder.Configure<Avalonia.Application>()
    .UsePlatformDetect()
    .LogToTrace()
    .SetupWithoutStarting();

// 手动添加主题
Avalonia.Application.Current!.Styles.Add(new SemiTheme());

// 如果需要自定义样式，也可以手动添加
// var styles = new Styles();
// styles.Add(new StyleInclude(new Uri("resm:Styles?assembly=RevitAva"))
// {
//     Source = new Uri("/Styles/CustomStyles.axaml", UriKind.Relative)
// });
// Avalonia.Application.Current!.Styles.Add(styles);
```

---

## 6. 窗口创建和显示对比

### 标准应用模式
```csharp
public override void OnFrameworkInitializationCompleted()
{
    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
    {
        // 主窗口由生命周期管理
        desktop.MainWindow = new MainWindow();
    }
    base.OnFrameworkInitializationCompleted();
}

// 关闭主窗口 = 应用程序退出
```

### 插件集成模式
```csharp
[Transaction(TransactionMode.Manual)]
public class SettingCommand : IExternalCommand
{
    public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
    {
        // 每次执行命令都创建新窗口
        var viewModel = Host.GetService<SettingViewModel>();
        var view = new SettingView { DataContext = viewModel };

        view.Show();  // 独立窗口，不影响 Revit

        return Result.Succeeded;
    }
}

// 关闭窗口 ≠ 应用程序退出
// Revit 继续运行，插件仍然加载
```

---

## 7. 最佳实践建议

### 标准应用模式适用场景
- ✅ 独立的桌面应用程序
- ✅ 需要完整的应用程序生命周期管理
- ✅ 单一主窗口应用
- ✅ 全局资源和样式需要集中管理

### 插件集成模式适用场景（本项目）
- ✅ Revit/AutoCAD/Rhino 等 CAD 软件插件
- ✅ 嵌入式 UI（集成到其他应用程序）
- ✅ 多窗口、按需创建场景
- ✅ 需要复用宿主的消息循环

---

## 8. 常见问题

### Q1: 为什么不创建 `App.axaml`？
**A:** Revit 插件环境下：
- 不需要应用程序级别的资源定义
- 样式可以在每个 View 的 XAML 中单独定义
- 或通过 `Avalonia.Application.Current.Styles` 在代码中添加

### Q2: 可以在插件中使用自定义 `App` 类吗？
**A:** 理论上可以，但不推荐：
```csharp
// ⚠️ 不推荐：可能与其他 Avalonia 插件冲突
public class MyApp : Avalonia.Application { }

AppBuilder.Configure<MyApp>()  // 使用自定义类
    .SetupWithoutStarting();
```
- 如果 Revit 加载了多个 Avalonia 插件，可能冲突
- 使用框架内置 `Avalonia.Application` 更安全

### Q3: `SetupWithoutStarting()` 和 `StartWithClassicDesktopLifetime()` 的区别？
**A:**
```csharp
// StartWithClassicDesktopLifetime(args)
// - 启动完整的应用程序生命周期
// - 创建独立的消息循环
// - 阻塞当前线程直到应用关闭
// - 适合独立应用

// SetupWithoutStarting()
// - 仅初始化 Avalonia 框架（渲染引擎、主题系统等）
// - 不创建消息循环，借用宿主的
// - 立即返回，不阻塞
// - 适合插件环境
```

### Q4: 如何在插件模式下添加全局样式？
**A:**
```csharp
// 方法 1：直接添加主题
Avalonia.Application.Current!.Styles.Add(new SemiTheme());

// 方法 2：加载外部样式文件
var styles = new Styles();
styles.Add(new StyleInclude(null)
{
    Source = new Uri("avares://RevitAva/Styles/CustomStyles.axaml")
});
Avalonia.Application.Current!.Styles.Add(styles);

// 方法 3：在每个 View 中定义
// SettingView.axaml:
<Window.Styles>
    <Style Selector="Button.Primary">
        <Setter Property="Background" Value="Blue"/>
    </Style>
</Window.Styles>
```

---

## 9. 总结

| 方面 | 标准模式 | 插件模式（本项目） |
|------|---------|------------------|
| **初始化** | `Configure<App>()` | `Configure<Avalonia.Application>()` |
| **启动** | `.StartWithClassicDesktopLifetime()` | `.SetupWithoutStarting()` |
| **资源定义** | App.axaml | 代码 + View.axaml |
| **消息循环** | 独立创建 | 借用宿主 |
| **适用场景** | 独立应用 | 插件/嵌入式 |

**本项目采用插件集成模式**，因为：
1. Revit 已经有消息循环，无需重复创建
2. 多个 Avalonia 插件可以共存
3. 窗口按需创建，不影响 Revit 运行
4. 轻量级集成，性能更好

---

## 参考资料

- [Avalonia Documentation - Application Lifetimes](https://docs.avaloniaui.net/)
- [Avalonia Discussion - Plugin System](https://github.com/AvaloniaUI/Avalonia/discussions/6824)
- [Windows Message Loop - MSDN](https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues)
