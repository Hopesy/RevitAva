# Avalonia 在 Revit 插件中的技术原理

本文档深入解释 Avalonia UI 框架在 Revit 插件中的工作原理，以及与 WPF 的对比。

## 目录

- [核心初始化代码解析](#核心初始化代码解析)
- [Avalonia 与 WPF 的共存原理](#avalonia-与-wpf-的共存原理)
- [为什么 WPF 不需要显式初始化](#为什么-wpf-不需要显式初始化)
- [平台后端架构](#平台后端架构)
- [消息循环机制](#消息循环机制)
- [主题系统](#主题系统)

---

## 核心初始化代码解析

在 `Application.cs` 中，我们使用以下代码初始化 Avalonia：

```csharp
private static void InitializeAvalonia()
{
    if (_avaloniaInitialized) return;

    AppBuilder.Configure<Avalonia.Application>()
        .UsePlatformDetect()
        .LogToTrace()
        .SetupWithoutStarting();

    // 设置 Fluent 主题
    Avalonia.Application.Current!.Styles.Add(new FluentTheme());

    _avaloniaInitialized = true;
}
```

让我们逐行分析每个方法的作用。

### 1. `AppBuilder.Configure<Avalonia.Application>()`

**作用**：创建应用程序构建器，指定应用程序类型。

**内部流程**（简化）：
```csharp
public static AppBuilder Configure<TApp>() where TApp : Application, new()
{
    var builder = new AppBuilder();
    builder.Instance = new TApp();  // 创建 Application 实例
    return builder;
}
```

**创建的对象**：
- `Avalonia.Application` 实例：管理全局资源、样式、生命周期
- `AppBuilder` 实例：用于链式配置

**为什么需要**：
- Avalonia 需要一个中心化的应用程序对象
- 管理全局资源字典
- 管理样式系统
- 管理主题
- 处理应用程序级别的事件

### 2. `.UsePlatformDetect()`

**作用**：自动检测运行平台并加载对应的后端实现。

**内部逻辑**（简化）：
```csharp
public AppBuilder UsePlatformDetect()
{
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        this.UseWin32();  // 加载 Avalonia.Win32.dll
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
    {
        this.UseX11();    // 加载 Avalonia.X11.dll
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
    {
        this.UseMacOS();  // 加载 Avalonia.Native.dll
    }
    return this;
}
```

**在 Windows 上加载的服务**：

| 服务类型 | 实现 | 作用 |
|---------|------|------|
| **窗口工厂** | `Win32WindowImpl` | 创建和管理 HWND |
| **渲染后端** | `SkiaRenderTarget` | 使用 Skia 渲染 UI |
| **输入处理** | `Win32InputManager` | 处理鼠标、键盘、触摸 |
| **剪贴板** | `Win32ClipboardImpl` | 访问系统剪贴板 |
| **文件对话框** | `Win32FileDialogs` | 显示打开/保存对话框 |
| **系统设置** | `Win32PlatformSettings` | 获取系统主题、DPI 等 |

**关键点**：
- 这一步注册了所有平台相关的服务
- 在 Windows 上，`Avalonia.Win32.dll` 负责与 Win32 API 交互
- 这些服务是 Avalonia 与操作系统交互的桥梁

### 3. `.LogToTrace()`

**作用**：启用日志输出到 .NET 的 `System.Diagnostics.Trace` 系统。

**内部实现**：
```csharp
public AppBuilder LogToTrace(LogEventLevel level = LogEventLevel.Warning)
{
    Logger.Sink = new TraceLogSink(level);
    return this;
}
```

**日志输出示例**：
```
[Avalonia] Initialized Win32 platform
[Avalonia] Created window with HWND: 0x00120456
[Avalonia] Loaded theme: FluentTheme
[Avalonia] Attached DevTools to window
```

**用途**：
- 调试 Avalonia 框架本身的问题
- 查看窗口创建、样式加载等事件
- 诊断性能问题

### 4. `.SetupWithoutStarting()`

**作用**：初始化 Avalonia 框架，但不启动应用程序生命周期。

**内部流程**（简化）：
```csharp
public AppBuilder SetupWithoutStarting()
{
    // 1. 初始化平台服���
    PlatformManager.Initialize();

    // 2. 注册类型转换器
    TypeConverterRegistry.Initialize();

    // 3. 初始化样式系统
    StyleSystem.Initialize();

    // 4. 初始化资源系统
    ResourceSystem.Initialize();

    // 5. 初始化输入系统
    InputManager.Initialize();

    // 6. 设置当前应用程序实例
    Application.Current = this.Instance;

    // 注意：不调用 Application.Run()
    // 不创建主窗口
    // 不启动消息循环

    return this;
}
```

**与 `StartWithClassicDesktopLifetime()` 的区别**：

| 方法 | 用途 | 是否启动消息循环 | 是否创建主窗口 |
|------|------|-----------------|---------------|
| `SetupWithoutStarting()` | 插件/嵌入式场景 | ❌ 否 | ❌ 否 |
| `StartWithClassicDesktopLifetime()` | 独立应用程序 | ✅ 是 | ✅ 是 |

**为什么在 Revit 插件中使用 `SetupWithoutStarting()`**：
- Revit 已经有自己的消息循环（WPF 的）
- 我们不能接管应用程序生命周期
- 只需要让 Avalonia 框架"准备好"创建窗口
- 窗口会自动使用 Revit 的消息循环

### 5. `Avalonia.Application.Current!.Styles.Add(new FluentTheme())`

**作用**：添加 Fluent 主题到全局样式集合。

**FluentTheme 包含的内容**：

```csharp
public class FluentTheme : Styles
{
    public FluentTheme()
    {
        // 1. 控件默认样式
        this.Add(new Style(x => x.OfType<Button>()) { /* Button 样式 */ });
        this.Add(new Style(x => x.OfType<TextBox>()) { /* TextBox 样式 */ });
        // ... 所有控件的样式

        // 2. 颜色方案
        this.Resources["SystemAccentColor"] = Color.Parse("#0078D4");
        this.Resources["SystemAccentColorLight1"] = Color.Parse("#429CE3");
        // ... 所有主题颜色

        // 3. 动画定义
        this.Resources["ButtonPressedAnimation"] = new Animation { /* ... */ };

        // 4. 资源字典
        this.Resources["DefaultFontFamily"] = new FontFamily("Segoe UI");
        this.Resources["DefaultFontSize"] = 14.0;
    }
}
```

**样式应用顺序**：
```
控件创建
    ↓
查找样式（从内到外）
    ↓
1. 控件本地样式 (Control.Styles)
2. 父容器样式
3. 窗口样式 (Window.Styles)
4. 应用程序样式 (Application.Current.Styles) ← FluentTheme 在这里
```

---

## Avalonia 与 WPF 的共存原理

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│              Windows 操作系统                            │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │   User32.dll - Windows 消息循环                │    │
│  │   GetMessage() / DispatchMessage()             │    │
│  └────────────────────────────────────────────────┘    │
│           ↓                           ↓                  │
│  ┌─────────────────┐        ┌─────────────────┐        │
│  │  WPF 窗口       │        │ Avalonia 窗口    │        │
│  │  (Revit)        │        │ (SettingView)    │        │
│  │                 │        │                  │        │
│  │  HWND: 0x1234   │        │  HWND: 0x5678    │        │
│  └─────────────────┘        └─────────────────┘        │
│           ↓                           ↓                  │
│  ┌─────────────────┐        ┌─────────────────┐        │
│  │ PresentationCore│        │ Avalonia.Win32   │        │
│  │ (WPF 渲染引擎)  │        │ (Avalonia 后端)  │        │
│  └─────────────────┘        └─────────────────┘        │
└─────────────────────────────────────────────────────────┘
```

### 关键概念：HWND（窗口句柄）

每个窗口都有一个唯一的 HWND：

```csharp
// WPF 窗口创建
var wpfWindow = new System.Windows.Window();
wpfWindow.Show();
// 内部：CreateWindowEx() → 返回 HWND: 0x00120456

// Avalonia 窗口创建
var avaloniaWindow = new Avalonia.Controls.Window();
avaloniaWindow.Show();
// 内部：CreateWindowEx() → 返回 HWND: 0x00120789
```

### 消息分发流程

```
1. 用户点击 Avalonia 窗口
   ↓
2. Windows 生成 WM_LBUTTONDOWN 消息
   ↓
3. GetMessage() 获取消息
   ↓
4. DispatchMessage() 根据 HWND 分发
   ↓
5. 调用 Avalonia 窗口的窗口过程 (WndProc)
   ↓
6. Avalonia.Win32 处理消息
   ↓
7. 触发 Avalonia 的 PointerPressed 事件
```

### 为什么可以共存？

**关键点**：
1. **独立的 HWND**：每个窗口都有自己的窗口句柄
2. **独立的窗口过程**：每个窗口有自己的消息处理函数
3. **共享消息循环**：但共享的是操作系统级别的消息循环，不是 WPF 的

**不是"借用"，而是"共享"**：
- Avalonia 不是借用 WPF 的消息循环
- 它们都使用 Windows 的消息循环
- 就像两个独立的应用程序可以同时运行一样

---

## 为什么 WPF 不需要显式初始化

### 关键场景：插件项目中没有 App.xaml

这是最重要的区别！在 Revit 插件这种场景下：

**WPF 方式**（可以直接使用）：
```csharp
// 在 Revit 插件的 Command 中
public class MyCommand : IExternalCommand
{
    public Result Execute(...)
    {
        // 直接创建 WPF 窗口，无需任何初始化
        var window = new System.Windows.Window
        {
            Title = "我的窗口",
            Content = new System.Windows.Controls.Button
            {
                Content = "点击我"
            }
        };
        window.Show();
        return Result.Succeeded;
    }
}
// ✅ 这样就可以工作！按钮有样式，窗口正常显示
```

**Avalonia 方式**（必须先初始化）：
```csharp
// 在 Revit 插件的 Command 中
public class MyCommand : IExternalCommand
{
    public Result Execute(...)
    {
        // 直接创建 Avalonia 窗口
        var window = new Avalonia.Controls.Window
        {
            Title = "我的窗口",
            Content = new Avalonia.Controls.Button
            {
                Content = "点击我"
            }
        };
        window.Show();
        return Result.Succeeded;
    }
}
// ❌ 这样会失败！抛出异常：
// "Avalonia has not been initialized. Call AppBuilder.Configure()..."
```

### WPF 的静态初始化机制

**关键点**：WPF 使用**静态构造函数**自动初始化，即使没有 App.xaml 或 Application 实例。

#### 1. 静态构造函数自动执行

当你第一次使用任何 WPF 类型时，静态构造函数会自动执行：

```csharp
// System.Windows.Application 类（WPF 内部）
public class Application : DispatcherObject
{
    // 静态构造函数：在类型第一次被使用时自动执行
    static Application()
    {
        // 1. 初始化渲染引擎
        MediaContext.Initialize();

        // 2. 加载系统主题资源
        LoadSystemTheme();

        // 3. 注册默认样式
        RegisterDefaultStyles();

        // 4. 初始化输入系统
        InputManager.Initialize();

        // 5. 初始化资源系统
        ResourceDictionary.Initialize();
    }

    private static void LoadSystemTheme()
    {
        // 从 PresentationFramework.dll 加载内置主题
        var themeUri = new Uri("pack://application:,,,/PresentationFramework;component/themes/aero.normalcolor.xaml");
        var theme = (ResourceDictionary)Application.LoadComponent(themeUri);

        // 设置为全局默认主题
        SystemResources.SetTheme(theme);
    }

    private static void RegisterDefaultStyles()
    {
        // 为每个控件注册默认样式
        DefaultStyleKeyProperty.OverrideMetadata(
            typeof(Button),
            new FrameworkPropertyMetadata(typeof(Button)));

        DefaultStyleKeyProperty.OverrideMetadata(
            typeof(TextBox),
            new FrameworkPropertyMetadata(typeof(TextBox)));

        // ... 所有控件
    }
}
```

**触发时机**：
```csharp
// 当你写这行代码时
var window = new System.Windows.Window();
                    ↓
// CLR 加载 System.Windows.Window 类型
                    ↓
// 发现 Window 继承自 FrameworkElement
                    ↓
// 加载 FrameworkElement 类型
                    ↓
// 发现 FrameworkElement 使用了 Application 类型
                    ↓
// 加载 Application 类型
                    ↓
// 执行 Application 的静态构造函数
                    ↓
// ✅ WPF 框架已初始化！
```

#### 2. 内置主题资源

WPF 的默认样式内置在 `PresentationFramework.dll` 中：

```
PresentationFramework.dll
└── themes/
    ├── aero.normalcolor.xaml       (Windows 7 Aero 主题)
    ├── aero2.normalcolor.xaml      (Windows 8/10 主题)
    ├── aerolite.normalcolor.xaml   (Windows 8 高对比度)
    └── classic.xaml                (经典主题)
```

这些资源会在静态构造函数中自动加载：

```csharp
// WPF 内部逻辑
static void LoadSystemTheme()
{
    // 检测 Windows 版本
    var osVersion = Environment.OSVersion.Version;
    string themeFile;

    if (osVersion.Major >= 10)
        themeFile = "aero2.normalcolor.xaml";  // Windows 10/11
    else if (osVersion.Major >= 6)
        themeFile = "aero.normalcolor.xaml";   // Windows 7/8
    else
        themeFile = "classic.xaml";            // Windows XP

    // 加载主题
    var uri = new Uri($"pack://application:,,,/PresentationFramework;component/themes/{themeFile}");
    var theme = (ResourceDictionary)Application.LoadComponent(uri);

    // 应用到全局
    SystemResources.SetTheme(theme);
}
```

#### 3. 默认样式自动应用

每个 WPF 控件都有默认样式，存储在主题文件中：

```xml
<!-- aero2.normalcolor.xaml 中的 Button 样式 -->
<Style x:Key="{x:Type Button}" TargetType="Button">
    <Setter Property="Background" Value="{StaticResource Button.Static.Background}"/>
    <Setter Property="BorderBrush" Value="{StaticResource Button.Static.Border}"/>
    <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
    <Setter Property="BorderThickness" Value="1"/>
    <Setter Property="Padding" Value="1"/>
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="Button">
                <!-- 完整的按钮模板 -->
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>
```

当你创建 Button 时：
```csharp
var button = new Button();
// WPF 自动：
// 1. 查找 Button 的默认样式（从已加载的主题中）
// 2. 应用样式
// 3. 按钮有了完整的外观和行为
```

### Avalonia 的显式配置理念

**关键点**：Avalonia **没有**静态初始化逻辑，必须显式配置。

#### 1. 没有静态构造函数初始化

```csharp
// Avalonia.Application 类（Avalonia 内部）
public class Application : IApplicationLifetime
{
    // ❌ 没有静态构造函数！
    // ❌ 不会自动初始化任何东西！

    public Application()
    {
        // 实例构造函数也不做初始化
        // 只是创建一个空的 Application 对象
    }
}
```

如果你直接创建 Avalonia 窗口：
```csharp
var window = new Avalonia.Controls.Window();
                    ↓
// CLR 加载 Avalonia.Controls.Window 类型
                    ↓
// ❌ 没有触发任何初始化！
                    ↓
window.Show();
                    ↓
// ❌ 抛出异常：
// InvalidOperationException:
// "Avalonia has not been initialized.
//  Call AppBuilder.Configure() before using any Avalonia types."
```

#### 2. 必须显式初始化

```csharp
// 必须先调用这些方法
AppBuilder.Configure<Avalonia.Application>()
    .UsePlatformDetect()      // 选择平台后端（Win32/X11/Cocoa）
    .LogToTrace()             // 配置日志
    .SetupWithoutStarting();  // 初始化框架

// 必须手动添加主题
Avalonia.Application.Current!.Styles.Add(new FluentTheme());

// 现在才能创建窗口
var window = new Avalonia.Controls.Window();
window.Show();  // ✅ 现在可以工作了
```

#### 3. 为什么 Avalonia 不使用静态初始化？

**原因 1：跨平台需求**

```csharp
// 如果 Avalonia 使用静态构造函数
static Application()
{
    // ❌ 问题：我在哪个平台上？
    if (IsWindows)
        InitializeWin32();  // 使用 Win32 后端
    else if (IsLinux)
        InitializeX11();    // 使用 X11 后端？还是 Wayland？
    else if (IsMacOS)
        InitializeCocoa();  // 使用 Cocoa 后端
    else if (IsBrowser)
        InitializeWasm();   // 使用 WebAssembly 后端

    // ❌ 太多假设，太不灵活！
}
```

**原因 2：后端选择的灵活性**

即使在 Windows 上，也有多种选择：

```csharp
// 开发者可能想要不同的配置
AppBuilder.Configure<App>()
    .UseWin32()           // 使用 Win32 后端
    .UseSkia()            // 使用 Skia 渲染

// 或者
AppBuilder.Configure<App>()
    .UseWin32()           // 使用 Win32 后端
    .UseDirect2D1()       // 使用 Direct2D 渲染

// 或者
AppBuilder.Configure<App>()
    .UseWin32()
    .With(new Win32PlatformOptions
    {
        UseWgl = true,    // 使用 OpenGL
        RenderingMode = new[] { Win32RenderingMode.Wgl }
    })
```

**原因 3：主题系统**

Avalonia 没有内置主题，必须显式添加：

```csharp
// 选项 1：使用 Fluent 主题
Application.Current.Styles.Add(new FluentTheme());

// 选项 2：使用 Simple 主题
Application.Current.Styles.Add(new SimpleTheme());

// 选项 3：完全自定义主题
Application.Current.Styles.Add(new MyCustomTheme());

// 选项 4：不使用任何主题（控件没有样式）
// 什么都不添加
```

### 对比总结：插件场景下的差异

| 方面 | WPF | Avalonia |
|------|-----|----------|
| **无 App.xaml 时** | ✅ 可以直接使用 | ❌ 必须先初始化 |
| **初始化方式** | 静态构造函数（自动） | AppBuilder（手动） |
| **触发时机** | 第一次使用 WPF 类型 | 显式调用 Configure() |
| **默认主题** | 自动加载系统主题 | 无（必须手动添加） |
| **平台检测** | 不需要（固定 Windows） | 必须（UsePlatformDetect） |
| **后端选择** | 固定（DirectX） | 可选（Win32/X11/Cocoa） |
| **代码量** | 0 行（自动） | ~10 行（手动配置） |

### Avalonia 的显式配置理念

#### 为什么 Avalonia 不能自动初始化？

**1. 跨平台需求**

Avalonia 必须支持多个平台，不能假设运行环境：

```csharp
// Avalonia 不能这样做：
static Avalonia.Application()
{
    // 问题：我在哪个平台上？
    // - Windows? 使用 Win32
    // - Linux? 使用 X11 还是 Wayland？
    // - macOS? 使用 Cocoa
    // - Browser? 使用 WebAssembly

    // 必须让开发者明确指定
}
```

**2. 后端选择**

在 Windows 上，Avalonia 也有多种选择：

```csharp
AppBuilder.Configure<App>()
    // 选项 1：自动检测
    .UsePlatformDetect()

    // 选项 2：明确指定 Win32
    .UseWin32()

    // 选项 3：明确指定渲染引擎
    .UseWin32()
    .UseSkia()  // 使用 Skia 渲染
    // 或
    .UseDirect2D1()  // 使用 Direct2D 渲染
```

**3. 主题系统**

WPF 有内置的系统主题，Avalonia 没有：

```csharp
// WPF：自动使用系统主题
var button = new System.Windows.Controls.Button();
// 自动应用 Aero/Luna 样式

// Avalonia：必须显式添加主题
Application.Current.Styles.Add(new FluentTheme());
var button = new Avalonia.Controls.Button();
// 现在才有样式
```

### 对比总结

| 方面 | WPF | Avalonia |
|------|-----|----------|
| **平台支持** | 仅 Windows | Windows/Linux/macOS/Browser |
| **初始化方式** | 自动（编译器生成） | 手动（显式配置） |
| **平台检测** | 不需要（固定 Windows） | 必须（UsePlatformDetect） |
| **后端选择** | 固定（DirectX） | 可选（Win32/X11/Cocoa/WASM） |
| **渲染引擎** | DirectX（固定） | Skia/Direct2D（可选） |
| **默认主题** | 系统主题（Aero/Luna） | 无（必须添加 FluentTheme） |
| **App.xaml** | 必需（编译时处理） | 可选（运行时配置） |
| **设计理念** | 约定优于配置 | 显式优于隐式 |

---

## 平台后端架构

### Avalonia 的分层架构

```
┌─────────────────────────────────────────────┐
│         应用层 (Application Layer)           │
│  Controls, Layouts, Styling, Data Binding  │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│      平台抽象层 (Platform Abstraction)       │
│  IWindowImpl, IPlatformSettings, etc.      │
└─────────────────────────────────────────────┘
                    ↓
┌──────────┬──────────┬──────────┬──────────┐
│  Win32   │   X11    │  Cocoa   │   WASM   │
│  后端    │   后端   │   后端   │   后端   │
└──────────┴──────────┴──────────┴──────────┘
                    ↓
┌─────────────────────────────────────────────┐
│         操作系统 (Operating System)          │
│     Windows / Linux / macOS / Browser      │
└─────────────────────────────────────────────┘
```

### Win32 后端的实现

**核心接口**：

```csharp
// 平台抽象层定义
public interface IWindowImpl
{
    void Show();
    void Hide();
    void SetTitle(string title);
    void SetPosition(PixelPoint position);
    void SetSize(Size size);
    void Invalidate(Rect rect);
    // ... 更多方法
}
```

**Win32 实现**：

```csharp
// Avalonia.Win32.dll 中的实现
public class Win32WindowImpl : IWindowImpl
{
    private IntPtr _hwnd;  // Windows 窗口句柄

    public void Show()
    {
        // 调用 Win32 API
        ShowWindow(_hwnd, SW_SHOW);
        UpdateWindow(_hwnd);
    }

    public void SetTitle(string title)
    {
        // 调用 Win32 API
        SetWindowText(_hwnd, title);
    }

    public void Invalidate(Rect rect)
    {
        // 调用 Win32 API
        RECT winRect = ToWin32Rect(rect);
        InvalidateRect(_hwnd, ref winRect, false);
    }

    // 窗口过程：处理 Windows 消息
    private IntPtr WndProc(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        switch (msg)
        {
            case WM_PAINT:
                OnPaint();
                break;
            case WM_LBUTTONDOWN:
                OnMouseDown(lParam);
                break;
            case WM_KEYDOWN:
                OnKeyDown(wParam);
                break;
            // ... 处理所有消息
        }
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}
```

### 渲染管线

```
1. 布局计算 (Layout)
   ↓
2. 生成绘制指令 (Drawing Context)
   ↓
3. 渲染后端处理
   ├─ Skia: 使用 SkiaSharp 渲染
   └─ Direct2D: 使用 Direct2D API 渲染
   ↓
4. 输出到屏幕
```

---

## 消息循环机制

### Windows 消息循环基础

```csharp
// 标准的 Windows 消息循环
while (GetMessage(out MSG msg, IntPtr.Zero, 0, 0))
{
    TranslateMessage(ref msg);
    DispatchMessage(ref msg);
}
```

### Revit (WPF) 的消息循环

```csharp
// WPF 的消息循环（简化）
public class Dispatcher
{
    public void Run()
    {
        while (!_hasShutdownStarted)
        {
            // 获取消息
            if (GetMessage(out MSG msg, IntPtr.Zero, 0, 0))
            {
                // WPF 特殊处理
                if (IsWpfMessage(msg))
                {
                    ProcessWpfMessage(msg);
                }
                else
                {
                    // 标准处理
                    TranslateMessage(ref msg);
                    DispatchMessage(ref msg);
                }
            }
        }
    }
}
```

### Avalonia 窗口如何接入

```csharp
// Avalonia 窗口创建时
public class Win32WindowImpl : IWindowImpl
{
    public Win32WindowImpl()
    {
        // 1. 创建窗口
        _hwnd = CreateWindowEx(
            0,
            "AvaloniaWindow",  // 窗口类名
            "My Window",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            800, 600,
            IntPtr.Zero,
            IntPtr.Zero,
            IntPtr.Zero,
            IntPtr.Zero
        );

        // 2. 注册窗口过程
        SetWindowLongPtr(_hwnd, GWLP_WNDPROC,
            Marshal.GetFunctionPointerForDelegate(WndProc));
    }

    // 3. 窗口过程：接收消息
    private IntPtr WndProc(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        // 处理消息并转换为 Avalonia 事件
        switch (msg)
        {
            case WM_PAINT:
                // 触发 Avalonia 的渲染
                _owner?.Paint?.Invoke();
                break;
        }
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}
```

**关键点**：
- Avalonia 窗口有自己的 HWND
- 有自己的窗口过程（WndProc）
- 自动接入到 Windows 消息循环
- 不需要 Revit/WPF 做任何特殊处理

---

## 主题系统

### WPF 主题系统

**自动加载**：
```csharp
// WPF 启动时自动执行
static class ThemeManager
{
    static ThemeManager()
    {
        // 检测 Windows 版本和主题
        var theme = DetectSystemTheme();

        // 加载对应的主题资源
        LoadTheme($"Themes/{theme}.xaml");
    }
}
```

**主题文件结构**：
```
PresentationFramework.dll
└── Themes/
    ├── Aero.NormalColor.xaml    (Windows 7)
    ├── Aero2.NormalColor.xaml   (Windows 8/10)
    └── Luna.NormalColor.xaml    (Windows XP)
```

### Avalonia 主题系统

**手动添加**：
```csharp
// 必须显式添加主题
Application.Current.Styles.Add(new FluentTheme());
```

**FluentTheme 结构**：
```csharp
public class FluentTheme : Styles
{
    public FluentTheme()
    {
        // 加载所有控件样式
        this.Add(new StyleInclude(new Uri("resm:Styles?assembly=Avalonia.Themes.Fluent"))
        {
            Source = new Uri("avares://Avalonia.Themes.Fluent/Controls/Button.xaml")
        });

        // 加载颜色资源
        this.Resources.Add("SystemAccentColor", Color.Parse("#0078D4"));

        // 支持亮色/暗色主题
        this.RequestedThemeVariant = ThemeVariant.Default;
    }
}
```

**主题切换**：
```csharp
// Avalonia 支持运行时切换主题
Application.Current.RequestedThemeVariant = ThemeVariant.Dark;
```

---

## 总结

### 核心要点

1. **Avalonia 需要显式初始化**，因为它是跨平台框架，不能假设运行环境
2. **WPF 自动初始化**，因为它是 Windows 原生框架，编译器会生成初始化代码
3. **Avalonia 和 WPF 共存**，通过各自的 HWND 和窗口过程，共享 Windows 消息循环
4. **`SetupWithoutStarting()`** 是关键，它初始化框架但不接管应用程序生命周期
5. **主题必须手动添加**，Avalonia 没有默认主题

### 设计理念对比

| WPF | Avalonia |
|-----|----------|
| 约定优于配置 | 显式优于隐式 |
| 自动化 | 可控性 |
| Windows 专用 | 跨平台 |
| 编译时魔法 | 运行时配置 |

### 实际影响

对于 Revit 插件开发：
- ✅ 可以在 Revit 中使用 Avalonia
- ✅ 不会影响 Revit 的正常运行
- ✅ 可以使用 Avalonia 的所有功能
- ⚠️ 需要理解初始化流程
- ⚠️ 预览器有限制，使用 DevTools 代替

---

**参考资源**：
- [Avalonia 官方文档](https://docs.avaloniaui.net/)
- [Avalonia GitHub](https://github.com/AvaloniaUI/Avalonia)
- [Windows API 文档](https://docs.microsoft.com/en-us/windows/win32/)
